<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>JaxRsPath.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Microservice Engine</a> &gt; <a href="../index.html" class="el_bundle">ms-engine-spring-jaxrs</a> &gt; <a href="index.source.html" class="el_package">net.trajano.ms.engine.jaxrs</a> &gt; <span class="el_source">JaxRsPath.java</span></div><h1>JaxRsPath.java</h1><pre class="source lang-java linenums">package net.trajano.ms.engine.jaxrs;

import java.util.Arrays;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import io.vertx.core.Handler;
import io.vertx.core.http.HttpMethod;
import io.vertx.ext.web.Route;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;

public class JaxRsPath implements
    Comparable&lt;JaxRsPath&gt; {

    /**
     * Content types that get consumed by the path.
     */
    private final String[] consumes;

    private final boolean exact;

    /**
     * VertX HTTP method.
     */
    private final HttpMethod method;

    /**
     * Path.
     */
    private final String path;

    /**
     * Path regular expression applies when {@link #exact} is false.
     */
    private final String pathRegex;

    /**
     * Content types that are produced by the path.
     */
    private final String[] produces;

    /**
     * Constructs JaxRsPath.
     *
     * @param path
     *            path
     * @param consumes
     *            content types consumed
     * @param produces
     *            content types produced
     * @param method
     *            HTTP method.
     */
    public JaxRsPath(final String path,
        final String[] consumes,
        final String[] produces,
<span class="fc" id="L59">        final HttpMethod method) {</span>

<span class="pc bpc" id="L61" title="1 of 2 branches missed.">        if (path.isEmpty()) {</span>
<span class="nc" id="L62">            throw new IllegalArgumentException(&quot;path cannot be empty&quot;);</span>
        }
<span class="fc" id="L64">        this.path = path;</span>
<span class="fc" id="L65">        this.consumes = consumes;</span>
<span class="fc" id="L66">        this.produces = produces;</span>
<span class="fc" id="L67">        this.method = method;</span>
<span class="fc" id="L68">        final Pattern placeholderPattern = Pattern.compile(&quot;/\\{([^}]+)}&quot;);</span>
<span class="fc" id="L69">        final Pattern regexPlaceholderPattern = Pattern.compile(&quot;[-A-Za-z_0-9]+:\\s*(.+)&quot;);</span>
<span class="fc" id="L70">        final Matcher matcher = placeholderPattern.matcher(path);</span>

<span class="fc" id="L72">        final StringBuffer b = new StringBuffer();</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">        while (matcher.find()) {</span>
<span class="fc" id="L74">            final Matcher m2 = regexPlaceholderPattern.matcher(matcher.group(1));</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">            if (m2.matches()) {</span>
<span class="fc" id="L76">                matcher.appendReplacement(b, &quot;/&quot; + m2.group(1));</span>
            } else {
<span class="fc" id="L78">                matcher.appendReplacement(b, &quot;/[^/]+&quot;);</span>
            }
<span class="fc" id="L80">        }</span>
<span class="fc" id="L81">        matcher.appendTail(b);</span>
<span class="fc" id="L82">        pathRegex = b.toString();</span>
<span class="fc" id="L83">        exact = pathRegex.equals(path);</span>
<span class="fc" id="L84">    }</span>

    /**
     * Apply path to router and assign the appropriate handlers.
     *
     * @param router
     *            router
     * @param jaxRsHandler
     *            JAX-RS Handler
     * @param failureHandler
     *            failure handler
     */
    public void apply(final Router router,
        final Handler&lt;RoutingContext&gt; jaxRsHandler,
        final Handler&lt;RoutingContext&gt; failureHandler) {

<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (isGet()) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            if (isExact()) {</span>
<span class="fc" id="L102">                router.head(getPath());</span>
            } else {
<span class="fc" id="L104">                router.headWithRegex(getPathRegex());</span>
            }
        }

        Route route;
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (isExact()) {</span>
<span class="fc" id="L110">            route = router.route(getMethod(), getPath());</span>
        } else {
<span class="fc" id="L112">            route = router.routeWithRegex(getMethod(), getPathRegex());</span>
        }

<span class="fc bfc" id="L115" title="All 2 branches covered.">        for (final String mimeType : consumes) {</span>
<span class="fc" id="L116">            route = route.consumes(mimeType);</span>
        }
<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (final String mimeType : produces) {</span>
<span class="fc" id="L119">            route = route.produces(mimeType);</span>
        }
<span class="fc" id="L121">        route.handler(jaxRsHandler).failureHandler(failureHandler);</span>
<span class="fc" id="L122">    }</span>

    /**
     * Compares two JaxRsPath objects such that it is ordered by most specific and
     * lowest level first. It sorts it in reverse by path. A path with produces is
     * order before one than one that does not. {@inheritDoc}
     */
    @Override
    public int compareTo(final JaxRsPath o) {

<span class="fc bfc" id="L132" title="All 4 branches covered.">        if (exact &amp;&amp; !o.exact) {</span>
<span class="fc" id="L133">            return -1;</span>
<span class="fc bfc" id="L134" title="All 4 branches covered.">        } else if (!exact &amp;&amp; o.exact) {</span>
<span class="fc" id="L135">            return 1;</span>
        }

<span class="fc" id="L138">        final int c = o.path.compareTo(path);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (c != 0) {</span>
<span class="fc" id="L140">            return c;</span>
        }

<span class="pc bpc" id="L143" title="1 of 4 branches missed.">        if (isNoProduces() &amp;&amp; !o.isNoProduces()) {</span>
<span class="nc" id="L144">            return 1;</span>
<span class="pc bpc" id="L145" title="1 of 4 branches missed.">        } else if (!isNoProduces() &amp;&amp; o.isNoProduces()) {</span>
<span class="nc" id="L146">            return -1;</span>
        } else {
<span class="fc" id="L148">            return 0;</span>
        }
    }

    @Override
    public boolean equals(final Object obj) {

<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (this == obj) {</span>
<span class="fc" id="L156">            return true;</span>
        }
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L159">            return false;</span>
        }
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L162">            return false;</span>
        }
<span class="nc" id="L164">        final JaxRsPath other = (JaxRsPath) obj;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (!Arrays.equals(consumes, other.consumes)) {</span>
<span class="nc" id="L166">            return false;</span>
        }
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (method != other.method) {</span>
<span class="nc" id="L169">            return false;</span>
        }
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (!Objects.equals(path, other.path)) {</span>
<span class="nc" id="L172">            return false;</span>
        }
<span class="nc" id="L174">        return Arrays.equals(produces, other.produces);</span>
    }

    /**
     * Gets the VertX HTTP method.
     *
     * @return VertX HTTP method
     */
    public HttpMethod getMethod() {

<span class="fc" id="L184">        return method;</span>
    }

    /**
     * Gets the path that is specified in the JAX-RS classes.
     *
     * @return path
     */
    public String getPath() {

<span class="fc" id="L194">        return path;</span>
    }

    /**
     * Gets the path that is suitable for the router.
     *
     * @return path regular expression
     */
    public String getPathRegex() {

<span class="fc" id="L204">        return pathRegex;</span>
    }

    @Override
    public int hashCode() {

<span class="nc" id="L210">        final int prime = 31;</span>
<span class="nc" id="L211">        int result = 1;</span>
<span class="nc" id="L212">        result = prime * result + Arrays.hashCode(consumes);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        result = prime * result + (method == null ? 0 : method.hashCode());</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        result = prime * result + (path == null ? 0 : path.hashCode());</span>
<span class="nc" id="L215">        result = prime * result + Arrays.hashCode(produces);</span>
<span class="nc" id="L216">        return result;</span>
    }

    /**
     * Checks if the path is an exact one (i.e. no regex)
     *
     * @return exact path indicator
     */
    public boolean isExact() {

<span class="fc" id="L226">        return exact;</span>
    }

    private boolean isGet() {

<span class="fc bfc" id="L231" title="All 2 branches covered.">        return method == HttpMethod.GET;</span>
    }

    private boolean isNoProduces() {

<span class="fc bfc" id="L236" title="All 2 branches covered.">        return produces.length == 0;</span>
    }

    @Override
    public String toString() {

<span class="fc" id="L242">        return &quot;JaxRsPath [consumes=&quot; + Arrays.toString(consumes) + &quot;, exact=&quot; + exact + &quot;, method=&quot; + method + &quot;, path=&quot; + path + &quot;, pathRegex=&quot; + pathRegex + &quot;, produces=&quot; + Arrays.toString(produces) + &quot;]&quot;;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>